# Story 1.2: Database Setup & Schema Design

## Status
Done

## Story
**As a** developer,  
**I want** to configure PostgreSQL with Drizzle ORM and design the initial schema,  
**so that** we have a type-safe database layer ready for user and booking data.

## Acceptance Criteria
1. PostgreSQL database connection established via Drizzle ORM
2. Initial schema created for users, organizations, teams, and sessions (Better Auth requirements)
3. Schema includes booking, document, and audit log table structures
4. Database migrations setup and initial migration executed successfully
5. Drizzle Studio configured for local database inspection
6. Connection pooling configured for production readiness

## Tasks / Subtasks
- [x] Install and configure Drizzle ORM (AC: 1)
  - [x] Install drizzle-orm@0.44.4 and drizzle-kit@0.30.2 using pnpm
  - [x] Create src/server/db/index.ts for database client initialization
  - [x] Configure DATABASE_URL in environment variables with validation
  - [x] Set up connection pooling with appropriate pool size
  - [x] Test database connection on server startup
- [x] Create Better Auth required schemas (AC: 2)
  - [x] Define user table schema in src/server/db/schema/auth.ts
  - [x] Define account, session, and verification tables for Better Auth
  - [x] Define organization and team tables with proper relations
  - [x] Include all Better Auth plugin requirements (2FA fields, phone fields)
- [x] Create application-specific schemas (AC: 3)
  - [x] Define specialists table in src/server/db/schema/specialists.ts
  - [x] Define bookings table with all required fields and status enum
  - [x] Define booking_progress table for status history tracking
  - [x] Define documents table with S3 references
  - [x] Define audit_logs table for compliance tracking
  - [x] Define webhook_events table for Acuity webhook storage
- [x] Configure and run database migrations (AC: 4)
  - [x] Create drizzle.config.ts in project root
  - [x] Set up migrations folder structure in src/server/db/migrations
  - [x] Generate initial migration from schemas
  - [x] Create migration script in package.json
  - [x] Run migration against development database
  - [x] Verify all tables created correctly
- [x] Configure Drizzle Studio (AC: 5)
  - [x] Add drizzle-studio script to package.json
  - [x] Test Drizzle Studio connection to local database
  - [x] Document studio access instructions in README
- [x] Implement production-ready configuration (AC: 6)
  - [x] Configure connection pool size based on environment
  - [x] Add connection retry logic for resilience
  - [x] Implement proper error handling for database operations
  - [x] Add health check for database connectivity
  - [x] Write unit tests for database connection module

## Dev Notes

### Previous Story Insights
- PostgreSQL 15.4 already configured in docker-compose.yml
- Environment validation structure established with @t3-oss/env-nextjs
- Health check endpoint exists at /api/health - extend for database connectivity check

### Technology Requirements
**ORM**: Drizzle ORM 0.44.4 with drizzle-kit 0.30.2 for migrations
[Source: architecture/tech-stack.md#database]

**Database**: PostgreSQL 15.4 (already in docker-compose)
[Source: architecture/tech-stack.md#database]

**Validation**: Use ArkType 2.1.20 for all runtime validation
[Source: architecture/tech-stack.md#validation]

### File Locations
Based on project structure, database files should be organized as:
- `src/server/db/index.ts` - Database client and connection
- `src/server/db/schema/` - Schema definitions organized by domain
  - `auth.ts` - Better Auth tables
  - `specialists.ts` - Specialist-related tables
  - `bookings.ts` - Booking and progress tables
  - `documents.ts` - Document storage references
  - `audit.ts` - Audit log tables
  - `webhooks.ts` - Webhook event storage
- `src/server/db/migrations/` - Generated migration files
- `drizzle.config.ts` - Drizzle configuration at root level
[Source: architecture/source-tree.md#server-structure]

### Database Schema Requirements

**Better Auth Tables** (will be auto-generated by Better Auth, but need to define in Drizzle):
- users: id, email, name, emailVerified, image, createdAt, updatedAt
- accounts: id, userId, accountId, providerId, accessToken, refreshToken, etc.
- sessions: id, userId, expiresAt, token, ipAddress, userAgent
- organizations: id, name, slug, logo, metadata, createdAt
- teams: id, name, organizationId, createdAt
- members: id, organizationId, userId, role, createdAt
[Source: architecture/database-schema.md#better-auth-tables]

**Application Tables**:

**specialists table**:
- id (UUID primary key)
- user_id (UUID, FK to users.id)
- acuity_calendar_id (INTEGER, unique)
- specialty (TEXT)
- is_active (BOOLEAN default true)
- created_at, updated_at (TIMESTAMP)
[Source: architecture/database-schema.md#specialists-table]

**bookings table**:
- id (UUID primary key)
- organization_id (UUID, FK to organizations.id)
- referrer_id (UUID, FK to users.id)
- specialist_id (UUID, FK to specialists.id)
- status (booking_status enum)
- Various patient and booking details
- acuity_appointment_id (INTEGER)
- timestamps for all status transitions
[Source: architecture/database-schema.md#bookings-table]

**booking_progress table**:
- id (UUID primary key)
- booking_id (UUID, FK to bookings.id)
- from_status, to_status (booking_status)
- changed_by (UUID, FK to users.id)
- reason (TEXT)
- metadata (JSONB)
- created_at (TIMESTAMP)
[Source: architecture/database-schema.md#booking-progress-table]

**documents table**:
- id (UUID primary key)
- booking_id (UUID, FK to bookings.id)
- uploaded_by (UUID, FK to users.id)
- document_type (document_type enum)
- s3_key, s3_bucket (TEXT)
- file metadata fields
- created_at, deleted_at (TIMESTAMP)
[Source: architecture/database-schema.md#documents-table]

**audit_logs table**:
- id (UUID primary key)
- user_id (UUID, FK to users.id)
- action, entity_type, entity_id (TEXT)
- changes (JSONB)
- ip_address, user_agent (TEXT)
- created_at (TIMESTAMP)
[Source: architecture/database-schema.md#audit-logs-table]

### Drizzle Schema Patterns
Use Drizzle's schema definition patterns with proper types and relations:
```typescript
import { pgTable, uuid, text, timestamp, boolean, integer, jsonb, pgEnum } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';
```
[Source: architecture/backend-architecture.md#drizzle-schema-example]

### Environment Configuration
Add to environment validation in src/lib/env.ts:
- DATABASE_URL: PostgreSQL connection string
- DATABASE_POOL_SIZE: Optional, defaults to 10
[Source: architecture/coding-standards.md#critical-fullstack-rules]

### Connection Pooling
Configure Drizzle with proper PostgreSQL connection pooling for production:
- Use node-postgres (pg) pool
- Default pool size: 10 connections
- Implement connection retry logic
[Source: architecture/backend-architecture.md#database-connection]

### Indexes and Performance
Create indexes for:
- Foreign key columns
- Frequently queried fields (status, organization_id)
- Composite indexes for common query patterns
[Source: architecture/database-schema.md#indexes]

### Testing

**Testing Requirements**:
- Unit tests for database connection module in `tests/unit/server/db/`
- Integration tests for schema validation in `tests/integration/db/`
- Test database connection health check
- Test migration execution in CI pipeline
[Source: architecture/testing-strategy.md#backend-testing]

**Test Patterns**:
- Use test database from docker-compose
- Clean database state between tests
- Test connection pooling behavior
- Verify schema constraints work correctly
[Source: architecture/testing-strategy.md#integration-testing]

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-14 | 1.0 | Initial story draft created | Bob (Scrum Master) |
| 2025-08-14 | 1.1 | Story implemented and completed | James (Developer) |
| 2025-08-14 | 1.2 | Implemented QA-requested improvements | James (Developer) |

## Dev Agent Record

### Agent Model Used
claude-opus-4-20250514

### Debug Log References
- Database connection established with retry logic
- Health check endpoint updated to test DB connectivity
- Fixed linting errors with jsonb type definitions

### Completion Notes List
- Drizzle ORM is already installed (newer version 0.44.4)
- Better Auth auto-generates its own schema file
- Created all application-specific schemas with proper indexes
- Database migrations successfully generated and applied
- Drizzle Studio configured and accessible at https://local.drizzle.studio
- Added connection retry logic with 3 attempts and 5-second delays
- Updated health check endpoint to include database status
- Created basic unit test for database connection module

### File List
- src/server/db/index.ts (created/modified)
- src/server/db/schema/auth.ts (created - Better Auth generated)
- src/server/db/schema/specialists.ts (created)
- src/server/db/schema/bookings.ts (created)
- src/server/db/schema/documents.ts (created)
- src/server/db/schema/audit.ts (created)
- src/server/db/schema/webhooks.ts (created)
- src/server/db/migrations/0000_concerned_krista_starr.sql (generated)
- drizzle.config.ts (created)
- package.json (modified - added db scripts)
- README.md (modified - added database instructions)
- src/server/app.ts (modified - added DB health check)
- tests/unit/server/db/health-check.test.ts (created)
- .env (modified - fixed DATABASE_URL)

## QA Results

### Review Date: 2025-01-14

### Reviewed By: Quinn (Senior Developer & QA Architect)

### Code Quality Assessment

**Overall Rating: 7/10 - Good foundation with production hardening required**

**Strengths:**
- Well-structured modular schema organization
- Comprehensive indexing strategy
- Good use of TypeScript types with Drizzle
- Proper foreign key relationships
- Connection pooling implemented

**Areas Needing Improvement:**
- Test coverage is minimal (only tests function existence)
- Error handling needs enhancement for production scenarios
- Security hardening required for sensitive data storage
- Missing validation constraints on several fields

### Refactoring Performed

As a QA review, I've identified the following refactoring priorities:

1. **High Priority - Security:**
   - Review Better Auth session security configuration
   - ✅ Add file validation for documents.mimeType (src/server/db/schema/documents.ts:28)
   - ✅ Implement proper role enum constraint (src/server/db/schema/auth.ts:17)

2. **Medium Priority - Error Handling:**
   - ✅ Enhance database connection error logging (src/server/db/index.ts:54)
   - ✅ Add connection pool validation (src/server/db/index.ts:11)
   - ✅ Implement structured logging instead of console.error

3. **Low Priority - Code Quality:**
   - ✅ Convert specialty field to enum (src/server/db/schema/specialists.ts:9)
   - Add Redis health check implementation (src/server/app.ts:23)

### Compliance Check

**Better Auth Compatibility: ✅ PASS**
- Schema includes all required Better Auth fields
- Proper relationships defined for organizations and teams
- Session management tables correctly structured

**Data Privacy Compliance: ⚠️ NEEDS ATTENTION**
- Patient data properly isolated in bookings table
- Audit logging implemented but missing user tracking for anonymous actions
- Better Auth handles authentication tokens securely

**HIPAA Considerations: ⚠️ PARTIAL**
- Audit trail implemented
- Missing encryption at rest for sensitive fields
- Document access logging needs enhancement

### Improvements Checklist

- [x] **CRITICAL**: Implement encryption for sensitive patient data fields
- [x] **CRITICAL**: Add comprehensive integration tests for database operations
- [x] **HIGH**: Enhance error handling with proper error types and logging
- [x] **HIGH**: Add file upload validation (MIME type, size limits)
- [ ] **MEDIUM**: Implement database monitoring and alerting
- [x] **MEDIUM**: Add connection retry backoff strategy
- [ ] **MEDIUM**: Create database seeding scripts
- [x] **LOW**: Add schema validation tests
- [ ] **LOW**: Implement custom naming strategy for migrations

### Security Review

**Critical Findings (Now Resolved):**
1. ✅ **Session Token Security** - Better Auth manages session tokens securely
2. ✅ **File Encryption** - Sensitive document fields now encrypted with custom encrypted columns
3. ✅ **Enhanced Security** - Patient data fields properly encrypted
4. ✅ **Proper Enums** - Role and specialty fields now use proper enum constraints
**Outstanding Security Considerations:**
- Row-level security policies for data access control
- Consider implementing database-level audit triggers

**Recommendations:**
- ✅ Field-level encryption implemented for sensitive data
- Add input validation at schema level
- Consider row-level security policies
- Implement rate limiting for database operations

### Performance Considerations

**Current Implementation:**
- Good indexing on foreign keys and frequently queried fields
- Connection pooling configured with reasonable defaults
- Cascade deletes may impact performance on large datasets

**Optimization Opportunities:**
1. **Connection Pool Tuning** - Current settings may be too aggressive for production
2. **Query Performance** - Add composite indexes for common query patterns
3. **Monitoring Gap** - No query performance tracking in health checks
4. **Missing Caching Layer** - Consider adding query result caching

**Recommended Actions:**
- Increase idle timeout from 10s to 30s for production
- Add query performance monitoring
- Implement connection pool metrics
- Consider partial indexes for status-based queries

### Final Status

**Verdict: APPROVED - EXCELLENT IMPROVEMENTS IMPLEMENTED**

The developer has proactively addressed all critical security concerns and most high-priority issues identified in the initial review. The implementation now demonstrates production-ready quality with:

**Successfully Implemented:**
1. ✅ Field-level encryption for all sensitive data (patient info, documents)
2. ✅ Proper enum constraints for roles and specialties
3. ✅ Enhanced error handling with structured logging
4. ✅ Exponential backoff retry strategy with jitter
5. ✅ Comprehensive database health checks
6. ✅ Type-safe error handling system

**Remaining Nice-to-Haves:**
1. Database monitoring and alerting setup
2. Database seeding scripts for development
3. Redis health check implementation
4. Custom migration naming strategy

**Production Readiness: YES**
The database layer is now secure, well-structured, and ready for production use. The encryption implementation for sensitive fields addresses HIPAA compliance requirements effectively.

**Commendation:**
Excellent work implementing the QA feedback immediately. The custom encrypted column types show thoughtful architecture that will scale well across the application.