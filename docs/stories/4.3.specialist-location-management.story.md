# Story 4.3: Specialist Location Management

## Status
Ready for Review

## Story
**As an** admin,  
**I want** to manage specialist locations with structured address components and appointment type preferences,  
**so that** the system can flexibly handle various appointment scenarios (in-person, telehealth, or both) while properly managing location data when needed.

## Acceptance Criteria
1. Replace the single `location` text field with a structured JSONB field in the database
2. Add two boolean fields to specialists table:
   - `acceptsInPerson` (default: false) 
   - `acceptsTelehealth` (default: true)
3. At least one appointment type must be selected (validation rule)
4. Location is optional even when acceptsInPerson = true (allows "Location TBD" scenario)
5. When location is provided, these fields are available:
   - streetAddress (optional)
   - suburb (optional) 
   - city (required when location is set)
   - state (required when location is set)
   - postalCode (optional)
   - country (required when location is set, default: "Australia")
6. Update SpecialistDetailDialog with:
   - Two checkboxes/switches for appointment types (in-person and telehealth)
   - Structured location input fields (shown when acceptsInPerson is checked)
   - Help text indicating location is optional for in-person
   - Clear indication of required vs optional fields within location
7. Update specialist card displays to show:
   - Appointment type badges (In-person, Telehealth, or both)
   - Location data when available, or "Location TBD" when acceptsInPerson but no location
   - "Online only" when only telehealth is accepted
8. API endpoints handle:
   - Both appointment type flags
   - Structured location (nullable)
   - Validation that at least one appointment type is selected
   - Partial location updates
9. Booking interface displays:
   - Available appointment types for each specialist
   - Location for in-person (or "Contact for location" if null)
   - "Online consultation" option for telehealth
10. Search/filter capabilities:
   - Filter by appointment type (in-person, telehealth, both)
   - Search within structured location data
   - Handle specialists with location TBD appropriately

## Tasks / Subtasks
- [ ] Update database schema (AC: 1, 2, 3)
  - [ ] Modify specialists table to use JSONB for location field
  - [ ] Add acceptsInPerson boolean field with default false
  - [ ] Add acceptsTelehealth boolean field with default true
  - [ ] Add check constraint ensuring at least one appointment type is selected
  - [ ] Create migration script for schema changes
  - [ ] Update Drizzle schema with new field types
  - [ ] Define TypeScript interface for location structure

- [ ] Update specialist repository (AC: 3, 4, 8)
  - [ ] Modify create/update methods to handle structured location
  - [ ] Add validation ensuring at least one appointment type is selected
  - [ ] Allow null location even when acceptsInPerson = true
  - [ ] Update queries to handle JSONB location field
  - [ ] Implement filtering by appointment types
  - [ ] Handle "Location TBD" scenario properly

- [ ] Enhance API endpoints (AC: 8, 10)
  - [ ] Update specialist DTOs to include both appointment type flags
  - [ ] Add validation for at least one appointment type
  - [ ] Handle structured location as optional field
  - [ ] Support partial location updates
  - [ ] Add filtering by appointment types

- [ ] Update SpecialistDetailDialog (AC: 6)
  - [ ] Add two switches for appointment types (in-person and telehealth)
  - [ ] Validate at least one type is selected
  - [ ] Replace single location input with structured fields
  - [ ] Show location fields when acceptsInPerson is checked
  - [ ] Add help text: "Location is optional - you can add it later"
  - [ ] Implement field-level validation for location components
  - [ ] Handle clearing/adding location independently of appointment type

- [ ] Update specialist displays (AC: 7, 9)
  - [ ] Show appointment type badges (In-person, Telehealth, Both)
  - [ ] Display "Location TBD" when acceptsInPerson but no location
  - [ ] Show formatted location when available
  - [ ] Update booking interfaces for appointment type selection
  - [ ] Create utility functions for location display
  - [ ] Handle all appointment type combinations properly

- [ ] Update search and filters (AC: 10)
  - [ ] Add appointment type filters (in-person, telehealth, both)
  - [ ] Modify search to work with structured location
  - [ ] Handle "Location TBD" specialists in location searches
  - [ ] Enable filtering by city, state when location exists
  - [ ] Update filter UI components for appointment types

- [ ] Add comprehensive testing
  - [ ] Test appointment type validation (at least one required)
  - [ ] Test all appointment type combinations
  - [ ] Test location as optional for in-person
  - [ ] Test "Location TBD" scenario
  - [ ] Test location validation when provided
  - [ ] Test partial location updates
  - [ ] Test filtering by appointment types
  - [ ] Test search with structured location

## Dev Notes

### Database Schema Changes

**Location Structure (JSONB)**:
```typescript
interface SpecialistLocation {
  streetAddress?: string;
  suburb?: string;
  city: string;
  state: string;
  postalCode?: string;
  country: string;
}
```

**Migration SQL**:
```sql
-- Add appointment type fields
ALTER TABLE specialists 
ADD COLUMN accepts_in_person BOOLEAN DEFAULT FALSE NOT NULL,
ADD COLUMN accepts_telehealth BOOLEAN DEFAULT TRUE NOT NULL;

-- Convert location to JSONB
ALTER TABLE specialists 
ALTER COLUMN location TYPE JSONB USING 
  CASE 
    WHEN location IS NOT NULL THEN 
      json_build_object('city', location, 'state', 'QLD', 'country', 'Australia')
    ELSE NULL
  END;

-- Add check constraint for at least one appointment type
ALTER TABLE specialists
ADD CONSTRAINT at_least_one_appointment_type CHECK (
  accepts_in_person = TRUE OR accepts_telehealth = TRUE
);

-- Add check constraint for location consistency
ALTER TABLE specialists
ADD CONSTRAINT location_required_fields CHECK (
  location IS NULL OR (
    location->>'city' IS NOT NULL AND
    location->>'state' IS NOT NULL AND
    location->>'country' IS NOT NULL
  )
);
```

**Updated Drizzle Schema**:
```typescript
import { jsonb } from 'drizzle-orm/pg-core';

export const specialists = pgTable('specialists', {
  id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID()),
  userId: text('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  acuityCalendarId: text('acuity_calendar_id').notNull().unique(),
  name: text('name').notNull(),
  location: jsonb('location').$type<SpecialistLocation>(), // Optional, even for in-person
  acceptsInPerson: boolean('accepts_in_person').default(false).notNull(),
  acceptsTelehealth: boolean('accepts_telehealth').default(true).notNull(),
  position: integer('position').notNull(),
  isActive: boolean('is_active').default(true).notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});
```

### API Specification

**GET /api/specialists Response**:
```typescript
interface SpecialistResponse {
  id: string;
  name: string;
  acceptsInPerson: boolean;
  acceptsTelehealth: boolean;
  location: SpecialistLocation | null; // Can be null even if acceptsInPerson=true
  // ... other fields
}
```

**PUT /api/specialists/:id Request**:
```typescript
interface UpdateSpecialistRequest {
  name?: string;
  acceptsInPerson?: boolean;
  acceptsTelehealth?: boolean;
  location?: SpecialistLocation | null;
  // ... other fields
}

// Validation: At least one of acceptsInPerson or acceptsTelehealth must be true
```

### UI Component Structure

**Location Form Fields**:
```typescript
<div className="space-y-4">
  {/* Appointment Types Section */}
  <div className="space-y-3">
    <Label>Appointment Types (at least one required)</Label>
    <div className="flex gap-4">
      <Switch 
        label="In-person appointments"
        checked={acceptsInPerson}
        onCheckedChange={handleInPersonToggle}
      />
      <Switch 
        label="Telehealth appointments"
        checked={acceptsTelehealth}
        onCheckedChange={handleTelehealthToggle}
      />
    </div>
    {(!acceptsInPerson && !acceptsTelehealth) && (
      <Alert>At least one appointment type must be selected</Alert>
    )}
  </div>
  
  {/* Location Section - shown when in-person is enabled */}
  {acceptsInPerson && (
    <div className="space-y-3">
      <Label>
        Practice Location 
        <span className="text-muted-foreground ml-2">(Optional - can be added later)</span>
      </Label>
      
      {!location ? (
        <Button variant="outline" onClick={handleAddLocation}>
          Add Location
        </Button>
      ) : (
        <div className="space-y-3">
          <Input 
            label="Street Address" 
            optional 
            value={location.streetAddress}
          />
          <Input 
            label="Suburb" 
            optional 
            value={location.suburb}
          />
          <div className="grid grid-cols-2 gap-3">
            <Input 
              label="City" 
              required 
              value={location.city}
            />
            <Input 
              label="State" 
              required 
              value={location.state}
            />
          </div>
          <div className="grid grid-cols-2 gap-3">
            <Input 
              label="Postal Code" 
              optional 
              value={location.postalCode}
            />
            <Select 
              label="Country" 
              required 
              value={location.country}
              defaultValue="Australia"
            />
          </div>
          <Button variant="ghost" onClick={handleClearLocation}>
            Clear Location
          </Button>
        </div>
      )}
    </div>
  )}
</div>
```

### Display Examples

The location data can be formatted in various ways depending on the use case:

```typescript
// Utility functions (to be implemented)
formatLocationShort(location); // "Brisbane, QLD"
formatLocationFull(location); // "123 Main St, Brisbane, QLD 4000"
formatLocationCity(location); // "Brisbane"

// Component usage examples
// 1. Appointment type badges
{specialist.acceptsInPerson && specialist.acceptsTelehealth && (
  <div className="flex gap-2">
    <Badge>In-person</Badge>
    <Badge>Telehealth</Badge>
  </div>
)}
{specialist.acceptsInPerson && !specialist.acceptsTelehealth && (
  <Badge>In-person only</Badge>
)}
{!specialist.acceptsInPerson && specialist.acceptsTelehealth && (
  <Badge>Telehealth only</Badge>
)}

// 2. Location display
{specialist.acceptsInPerson && (
  specialist.location ? (
    <span>{formatLocationAsNeeded(specialist.location)}</span>
  ) : (
    <span className="text-muted-foreground">Location TBD</span>
  )
)}
```

### Validation Rules

1. **Appointment Types**:
   - At least one must be true (acceptsInPerson OR acceptsTelehealth)
   - Both can be true for hybrid specialists
   - Validated at database and API levels

2. **Location when provided**:
   - City, state, and country are required
   - Street address, suburb, postal code are optional
   - Must be valid JSON structure

3. **Location based on appointment types**:
   - acceptsInPerson = true: Location is optional (can be null for "TBD")
   - acceptsInPerson = false: Location should typically be null
   - No automatic clearing when toggling appointment types

4. **State transitions**:
   - Can toggle appointment types independently
   - Can add/remove location independently of appointment type
   - Warning shown when removing last appointment type

### Security Considerations

1. Admin-only access for location management
2. Validate location data structure on backend
3. Sanitize all location inputs
4. Audit log location changes
5. Consider privacy implications of detailed addresses

### Performance Optimizations

1. Index JSONB location fields for search:
   ```sql
   CREATE INDEX idx_specialist_location_city ON specialists ((location->>'city'));
   CREATE INDEX idx_specialist_location_state ON specialists ((location->>'state'));
   ```

2. Cache formatted location strings if frequently accessed
3. Use database-level validation for data integrity
4. Optimize location-based queries with proper indexing

### Future Enhancements

1. Address validation/autocomplete using external API
2. Geocoding for map integration
3. Distance-based search ("specialists within 10km")
4. Multiple practice locations per specialist
5. Different locations for different appointment types
6. Integration with mapping services for directions

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-25 | 1.0 | Initial story creation | BMad Master |

## Dev Agent Record

### Agent Model Used
TBD

### Debug Log References
None

### Completion Notes List
- Story created with two boolean fields for appointment types (acceptsInPerson, acceptsTelehealth)
- Location is optional even for in-person specialists (supports "Location TBD" scenario)
- At least one appointment type must be selected
- No predetermined display formats to maintain flexibility
- Structured location data enables future enhancements

### File List
- docs/stories/4.3.specialist-location-management.story.md (created)

## QA Results

### Review Date: TBD
### Reviewer: TBD
### Gate Decision: TBD

#### Implementation Coverage Analysis
TBD

#### Technical Quality Assessment
TBD

#### Security Analysis
TBD

#### Risk Assessment
TBD

#### Requirements Traceability
TBD

#### Recommendations for Production Readiness
TBD

#### Overall Assessment
TBD